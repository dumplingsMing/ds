student ID: 5130379082
name: 赵子铭
email: dumplings_ming@sjtu.edu.cn

#文件介绍#
- Makefile：gnumakefile，用来编译整个项目，使用了gcc和g++。
- router.h：路由器的头文件，定义了路由器中用到的结构体们
- router.cpp：路由器的实现文件，实现了router.h中声明的函数
- dsdv.cpp：整个程序的main函数的所在地

#具体实现#
##总体流程##
整个程序在main函数中开启了两个线程，一个运行用来接收数据包的函数，一个用来运行发送数据包的函数。
两个线程内部都使用了死循环来不断地发包和收包，直到程序人为的收到了ctrl+c使进程中止为止。
主线程中使用了pthread_join函数来等待子线程运行完成（应该永远不会到达）

##总体算法##
整个程序使用了较为简化版本的dsdv策略，没有使用每隔一段时间序列号加二这一方法 ，从而避免了需要的延迟发送等操作。相反，本程序只有在接收到序列号比自身高的自身作为dst的路由条目时才会更新自身的序列号，使自己成为最新的一个序列号，从而传遍整个路由图；此外，本程序每次发送的都是完全路由包，从而简化了流程，而并不十分影响效率。

###发送方策略###
- 发送方每隔一定时间进行一次发送。
- 在每次发送时，对整个路由文件进行遍历，若存在发生改变过的边，则将边的长度设为新的长度，并遍历自身的路由表，将所有下一跳需要经过此边的路由项的序列号都加一，修改对应的路径消耗。
- 修改完成后，发送方将自己的全部路由表广播出去。
- 通过以上步骤，发送方就可以将某一条边的改变以一个更高的序号传达到整个路由图。

###接收方策略###
接收方策略相对复杂，当接收方收到一个包时，对收到的路由表中的每一项，主要存在以下三种情况
- 收到的序列号比当前的序列号低时：说明当前为较新的数据，因此忽略旧有的数据
- 收到的序列号比当前的序列号高时：
	- 若收到的路由表项的终点不是自身，说明自身有一条路由路径可能会经过改变的边，因此，将自身路由表中目的地相同的一项进行更新。
	- 若收到的路由表项终点是自身，增加自身的序列号至大于收到的序列号，从而重新计算所有以自身为终点的路径
- 若收到的序列号同当前的序列号相同：说明当前路由表中并没有发生变化，则使用正常的dv算法即可
